# -----------------------------------------------------------------------------
# Script: utils/oaxaca_grid.R
#
# Purpose:
#   To generate the hexagonal grid shapefile (`oaxaca_ZMO_grid.shp`) for the
#   Oaxaca ZMO (Zona Metropolitana de Oaxaca). This script aggregates population
#   and customer profile data from AGEB-level shapefiles to the hexagonal grid.
#
# Inputs:
#   - Oaxaca AGEB shapefiles: `../data/agebs_oaxaca/conjunto_de_datos/*.shp`
#     (Specifically, the one matching the pattern, typically the main AGEB file).
#   - Customer profile data: `data/perfiles.rds`
#     (Generated by the `utils/perfiles.R` script).
#
# Output:
#   - Hexagonal grid shapefile: `data/Oaxaca_grid/oaxaca_ZMO_grid.shp`
#
# Note:
#   This script is intended for manual execution as part of the data preparation
#   process. It should not be run directly by the Shiny application.
# -----------------------------------------------------------------------------

# --- Load Libraries ---
library(sf)
library(dplyr) # Used for data manipulation (pipes, filter, mutate, etc.)
# library(DataExplorer) # Used for EDA, optional for final output generation

# --- Load AGEB Shapefile ---
# Construct the path to the shapefile within the "agebs_oaxaca" directory
# Assumes there's one primary .shp file to be used.
shp_path_folder <- "../data/agebs_oaxaca/conjunto_de_datos"
shp_files <- list.files(shp_path_folder, pattern = "\\.shp$", full.names = TRUE)

if (length(shp_files) == 0) {
  stop("No .shp file found in ", shp_path_folder)
} else if (length(shp_files) > 1) {
  warning("Multiple .shp files found in ", shp_path_folder, ". Using the first one: ", shp_files[1])
}
agebs_oax <- st_read(shp_files[1], quiet = TRUE)

# --- Filter for Oaxaca ZMO Municipalities ---
# List of CVE_MUN (municipal codes) for the Oaxaca ZMO
mun_zmo <- c(
  '045', '063', '067', '083', '087', '091', '107', '115', '157', '174',
  '227', '293', '338', '350', '375', '385', '390', '399', '403', '409',
  '519', '539', '553', '565'
)

agebs_oax <- agebs_oax %>% 
  filter(CVE_MUN %in% mun_zmo) 

# --- Load Customer Profile Data ---
# This data is generated by 'utils/perfiles.R' and contains population totals
# and customer profile estimates per AGEB.
perfiles_data <- readRDS('data/perfiles.rds')
# glimpse(perfiles_data) # For quick inspection

# --- Join AGEB geometries with Profile Data ---
agebs_oax <- left_join(agebs_oax, perfiles_data, by = "CVEGEO")

# Filter out AGEBs that didn't match or have no population data
agebs_oax <- agebs_oax %>% 
  filter(!is.na(POBTOT)) # POBTOT comes from perfiles_data (originally from census)

# glimpse(agebs_oax) # For quick inspection

# --- Optional: Missing Values Check (using DataExplorer) ---
# This section can be uncommented for data quality checks during development.
# if (requireNamespace("DataExplorer", quietly = TRUE)) {
#   agebs_oax %>%
#     filter(is.na(POBTOT)) %>%
#     DataExplorer::plot_missing()
# }

# --- Create Hexagonal Grid ---
# Transform to a projected CRS (e.g., UTM) suitable for metric measurements (meters)
# EPSG:6372 is "Mexico ITRF2008 / UTM zone 14N", suitable for Oaxaca.
agebs_oax_proj <- st_transform(agebs_oax, crs = 6372)

hex_size_meters <- 500  # Desired size of each hexagon side in meters

# Create the hexagonal grid over the bounding box of the projected AGEBs
hex_grid_proj <- st_make_grid(
  agebs_oax_proj,
  cellsize = hex_size_meters,
  square = FALSE, # FALSE for hexagons
  what = "polygons"
) %>%
  st_sf() %>% # Convert to sf object
  mutate(id_hex = 1:n()) # Assign a unique ID to each hexagon

# Transform grid back to original CRS (WGS84, EPSG:4326) for consistency
hex_grid <- st_transform(hex_grid_proj, crs = st_crs(agebs_oax))

# --- Spatially Aggregate Data to Hexagons ---
# Ensure geometries are valid before intersection
agebs_oax_valid <- st_make_valid(agebs_oax)
hex_grid_valid <- st_make_valid(hex_grid)

# Perform spatial intersection
# This operation can be computationally intensive.
# It calculates the area of overlap between each AGEB and each hexagon.
intersection_sf <- st_intersection(hex_grid_valid, agebs_oax_valid)

# Aggregate data: sum relevant variables for each hexagon
# This assumes that data from AGEBs should be summed up if multiple AGEBs overlap a hexagon.
# For variables like population density or ratios, a weighted average based on area might be more appropriate.
aggregated_data_hex <- intersection_sf %>%
  # Calculate the area of each intersecting polygon (not strictly needed for sum, but useful for weighted avgs)
  # mutate(area_inter = st_area(.)) %>%
  st_drop_geometry() %>% # Drop geometry for faster grouping and summarization
  group_by(id_hex) %>%
  summarise(
    # Sum population and estimated customer counts from intersecting AGEBs
    # Ensure these columns exist in 'intersection_sf' (inherited from 'agebs_oax_valid')
    poblacion_total = sum(as.numeric(POBTOT), na.rm = TRUE),
    joven_digital = sum(as.numeric(estimado_ctes_joven), na.rm = TRUE),
    mama_emprendedora = sum(as.numeric(estimado_ctes_mama), na.rm = TRUE),
    mayorista_experimentado = sum(as.numeric(estimado_ctes_mayorista), na.rm = TRUE),
    clientes_totales = sum(as.numeric(estimado_ctes_total), na.rm = TRUE) # Renamed from ctes_total for clarity
  )

# --- Join Aggregated Data back to Hexagon Geometries ---
hex_grid_final <- left_join(hex_grid, aggregated_data_hex, by = "id_hex")

# Replace NA values (for hexagons with no intersecting AGEB data) with 0
hex_grid_final <- hex_grid_final %>%
  mutate(
    poblacion_total = ifelse(is.na(poblacion_total), 0, poblacion_total),
    joven_digital = ifelse(is.na(joven_digital), 0, joven_digital),
    mama_emprendedora = ifelse(is.na(mama_emprendedora), 0, mama_emprendedora),
    mayorista_experimentado = ifelse(is.na(mayorista_experimentado), 0, mayorista_experimentado),
    clientes_totales = ifelse(is.na(clientes_totales), 0, clientes_totales)
  )

# Filter out hexagons that might be outside the ZMO extent but were part of the initial grid creation
# This step ensures only hexagons with actual or potential data are kept.
# A common way is to filter based on whether they received any data.
hex_grid_final <- hex_grid_final %>%
  filter(poblacion_total > 0 | joven_digital > 0 | mama_emprendedora > 0 | mayorista_experimentado > 0 | clientes_totales > 0)

# Ensure final projection is WGS84 (EPSG:4326)
hex_grid_final <- st_transform(hex_grid_final, crs = "+proj=longlat +datum=WGS84")

# --- Save Output Shapefile ---
# Define output path and ensure directory exists
output_dir <- "data/Oaxaca_grid"
if (!dir.exists(output_dir)) {
  dir.create(output_dir, recursive = TRUE)
}
output_path <- file.path(output_dir, "oaxaca_ZMO_grid.shp")

# Delete existing file before writing, if necessary, to prevent errors
if (file.exists(output_path)) {
  message("Overwriting existing file: ", output_path)
  file.remove(output_path) # Or handle layers if it's a geopackage/multi-layer format
  # For shapefiles, associated files might also need removal (e.g. .dbf, .shx, .prj)
  related_files <- gsub("\\.shp$", "", output_path)
  sapply(paste0(related_files, c(".dbf", ".shx", ".prj", ".cpg")), function(f) if(file.exists(f)) file.remove(f))
}

st_write(hex_grid_final, output_path, driver = "ESRI Shapefile")

message("Successfully generated hexagonal grid shapefile: ", output_path)

# --- Final Inspection (Optional) ---
# glimpse(hex_grid_final)
# summary(hex_grid_final)
# if (nrow(hex_grid_final) > 0 && requireNamespace("leaflet", quietly = TRUE)) {
#   leaflet::leaflet(hex_grid_final) %>%
#     leaflet::addTiles() %>%
#     leaflet::addPolygons(fillColor = "blue", weight = 1, fillOpacity = 0.5, popup = ~id_hex) %>%
#     leaflet::fitBounds(lng1 = min(st_coordinates(hex_grid_final)[,1]),
#                        lat1 = min(st_coordinates(hex_grid_final)[,2]),
#                        lng2 = max(st_coordinates(hex_grid_final)[,1]),
#                        lat2 = max(st_coordinates(hex_grid_final)[,2]))
# }
